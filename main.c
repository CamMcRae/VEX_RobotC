#pragma config(Sensor, in1,    autonSelect2,   sensorPotentiometer)
#pragma config(Sensor, in2,    autonSelect1,   sensorPotentiometer)
#pragma config(Sensor, in3,    intakeSen,      sensorReflection)
#pragma config(Sensor, dgtl1,  punchLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl3,  rightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftBaseEnc,    sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           punch_1,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           baseLeft_1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           baseRight_1,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           baseLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           baseRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           punch_2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           roller,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          punch_3,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "utility.c"
#include "punch.c"
#include "toggles.c"
#include "auton.c"
//#include "intake.c"

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void pre_auton() {

	bStopTasksBetweenModes = false;
}

float pot1;
float pot2;

///////////////////////////// MANUAL CONTROLLERS ///////////////////////////////

///////////////////////////// BASE DRIVE ///////////////////////////////
void chassisController () {

	float l = vexRT[Ch2Xmtr2]/127.0;
	float r = vexRT[Ch3Xmtr2]/127.0;

	// CUBIC DRIVE
	float pwr_1 = l * abs(l * l);
	float pwr_2 = r * abs(r * r);

	float leftPwr = (reverseDrive ?  -pwr_1 : pwr_2) * (slowDrive ? 70.0 : 127.0);
	float rightPwr = (reverseDrive ? -pwr_2 : pwr_1) * (slowDrive ? 70.0 : 127.0);

	setBase(leftPwr, rightPwr);
}

////////////////// INTAKE ////////////////////
void intakeController() {
	// Main driver override
	float pwr2 = vexRT[Btn7UXmtr2] - vexRT[Btn7DXmtr2];
	motor[intake] = pwr2 * 127;

	// Secondary Driver
	float pwr = vexRT[Btn5U] - vexRT[Btn5D];
	if (pwr2 == 0){
		motor[intake] = pwr * 127;
	}
}

////////////////// CAP ROLLER ////////////////////
void rollerController() {
	float pwr = vexRT[Btn6U] - vexRT[Btn6D];
	motor[roller] = -pwr * 100;
}

////////////////// CAP ARM ////////////////////
void capFlipController() {
	float pwr = vexRT[Btn8U] - vexRT[Btn8D];
	motor[arm] = -pwr * 80;
}

task autonomous() {
	startTask(puncherController);

	//driveStraight(10, 1, true);

	//while(true) {

	//	pot1 = SensorValue[leftBaseEnc];//SensorValue[autonSelect1];

	//	pot2 = SensorValue[rightBaseEnc]; //SensorValue[autonSelect2];
	//	wait1Msec(20);
	//}

	//pointTurn(90, 0.5);

	pot1 = SensorValue[autonSelect1];

	bool num = SensorValue[autonSelect2] < 2048;

	//pot1 = 5000;

	if (pot1 < 600) {
		// red front
		if (num) {
			redFront_1();
			} else {
			redFront_2();
		}
		} else if (pot1 < 2048) {
		// red back
		if (num) {
			redBack_1();
			} else {
			redBack_2();
		}
		} else if (pot1 < 3300) {
		// blue front
		if (num) {
			blueFront_1();
			} else {
			blueFront_2();
		}
		} else if (pot1 < 5000) {
		// red back
		if (num) {
			blueBack_1();
			} else {
			blueBack_2();
		}
	} else if (pot1 == 5000) {
		skillsAuton();
	}
}

task usercontrol() {
	stopTask(puncherController);
	startTask(puncherController);

	while (true) {

		// drive toggles
		reverseToggle();
		slowToggle();
		cataToggle();

		// shooting buttons to prevent double shooting
		shootToggle();

		// main controllers
		chassisController();
		rollerController();
		intakeController();
		capFlipController();

		wait1Msec(10);
	}
}
