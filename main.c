#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftBaseEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  backBaseEnc,    sensorQuadEncoder)
#pragma config(Motor,  port1,           roller,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lift_1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           punch_1,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           punch_2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           baseLeft,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           baseRight,     tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port7,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lift_2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          intake,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "auton.c"
#include "utility.c"

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

typedef struct {
	// odometry things
	float leftDist;
	float rightDist;
	float backDist;

	float deltaLeft;
	float deltaRight;
	float deltaBack;

	float leftRadius;
	float rightRadius;
	float backRadius;

	float angle;
	float lastAngle;

	float posX;
	float posY;

	float lastPosX;
	float lastPosY;

} BotData;

BotData bot;

// wheel radius params;
bot.leftRadius = 2.75;
bot.rightRadius = 2.75;
bot.backRadius = 0;

typedef struct{
	bool firePunch;
	bool inPosition;
} linearPuncher;

linearPuncher punch;
punch.firePunch = false;
punch.inPosition = false;

bool reverseDrive = false;
bool reversePressed = false;

///////////////////////////// MANUAL CONTROLLERS ///////////////////////////////

///////////////////////////// BASE DRIVE ///////////////////////////////
void chassisController () {

	float l = vexRT[Ch2Xmtr2]/127.0;
	float r = vexRT[Ch3Xmtr2]/127.0;

	// CUBIC DRIVE
	float pwr_1 = l * abs(l * l);
	float pwr_2 = r * abs(r * r);

	motor[baseLeft] = reverseDrive ? -pwr_2 : pwr_1 * 127.0;
	motor[baseRight] = reverseDrive ? -pwr_1 : pwr_2 * 127.0;
}

////////////////// MAIN LIFT ////////////////////
void liftController(){
	float pwr = vexRT[Btn6U] - vexRT[Btn6D];
	motor[lift_1] = pwr * 127;
	motor[lift_2] = pwr * 127;
}

////////////////// INTAKE ////////////////////
void intakeController() {
	// Main driver override
	float pwr2 = vexRT[Btn7UXmtr2] - vexRT[Btn7DXmtr2];
	motor[intake] = pwr2 * 127;

	// Secondary Driver
	float pwr = vexRT[Btn5U] - vexRT[Btn5D];
	if (pwr2 == 0){
		motor[intake] = pwr * 127;
	}
}

////////////////// CAP ROLLER ////////////////////
void rollerController() {
	float pwr = vexRT[Btn7L] - vexRT[Btn7R];
	motor[roller] = -pwr * 100;
}

////////////////// PUNCH ////////////////////

task puncherController() {
	bool reset = false;
	bool lastValue = false;
	float punchPwr = 80;
	while (true) {

		// gets the current value from the limit switch
		reset = SensorValue[punchLimitSwitch] == 1 ? true : false;

		// tests if the punch has shot
		if (lastValue && !reset) {
			firePunch = false;
		}

		// override button when true
		if (firePunch) {
			motor[punch_1] = punchPwr;
			motor[punch_2] = -punchPwr;
			} else {
			// otherwise turn the motors to hit the button
			if (!reset) {
				motor[punch_1] = punchPwr;
				motor[punch_2] = -punchPwr;
				} else {
				motor[punch_1] = 0;
				motor[punch_2] = 0;
			}
		}
		lastValue = reset;
		wait1Msec(35);
	}
}

task autonomous()
{
	startTask(puncherController);
	startTask(odometry);
}

task usercontrol() {
	startTask(puncherController);

	while (true)
	{

		// reverse drive
		if (vexRT[Btn6DXmtr2]) {
			if (!reversePressed){
				reverseDrive = !reverseDrive;
			}
			reversePressed = true;
			} else {
			reversePressed = false;
		}

		chassisController();
		liftController();
		rollerController();
		intakeController();

		// fires punch
		if (vexRT[Btn6UXmtr2]){
			firePunch = true;
		}
		wait1Msec(10);
	}
}
